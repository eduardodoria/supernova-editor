
#include "Factory.h"

#include "Scene.h"
#include "Catalog.h"
#include <sstream>
#include <iomanip>
#include <cctype>
#include <array>
#include <fstream>
#include <unordered_set>
#include <algorithm>
#include <filesystem>

#include "util/FileUtils.h"

#include "resources/sky/Daylight_Box_Back_png.h"
#include "resources/sky/Daylight_Box_Bottom_png.h"
#include "resources/sky/Daylight_Box_Front_png.h"
#include "resources/sky/Daylight_Box_Left_png.h"
#include "resources/sky/Daylight_Box_Right_png.h"
#include "resources/sky/Daylight_Box_Top_png.h"

using namespace Supernova;

bool Editor::Factory::writeHeaderIfChanged(const fs::path& path, const std::string& varName, const unsigned char* data, size_t len) {
    std::ostringstream out;
    out << "// This file is auto-generated by Supernova Editor. Do not edit manually.\n\n";
    out << "#ifndef " << varName << "_H\n";
    out << "#define " << varName << "_H\n\n";

    out << "unsigned char " << varName << "_data[] = {";
    for (size_t i = 0; i < len; i++) {
        if (i % 20 == 0) {
            out << "\n    ";
        }
        out << "0x" << std::hex << std::setw(2) << std::setfill('0') << static_cast<int>(data[i]) << ", ";
    }
    out << "\n};\n";
    out << "const unsigned int " << varName << "_len = " << std::dec << len << ";\n\n";

    out << "#endif // " << varName << "_H\n";

    return FileUtils::writeIfChanged(path, out.str());
}

bool Editor::Factory::ensureDefaultSkyFiles(const fs::path& baseDir) {
    if (baseDir.empty()) {
        return false;
    }

    const fs::path frontPath = baseDir / "Daylight_Box_Front.h";
    const fs::path backPath = baseDir / "Daylight_Box_Back.h";
    const fs::path leftPath = baseDir / "Daylight_Box_Left.h";
    const fs::path rightPath = baseDir / "Daylight_Box_Right.h";
    const fs::path topPath = baseDir / "Daylight_Box_Top.h";
    const fs::path bottomPath = baseDir / "Daylight_Box_Bottom.h";

    if (!writeHeaderIfChanged(frontPath, "Daylight_Box_Front", Daylight_Box_Front_png, Daylight_Box_Front_png_len)) return false;
    if (!writeHeaderIfChanged(backPath, "Daylight_Box_Back", Daylight_Box_Back_png, Daylight_Box_Back_png_len)) return false;
    if (!writeHeaderIfChanged(leftPath, "Daylight_Box_Left", Daylight_Box_Left_png, Daylight_Box_Left_png_len)) return false;
    if (!writeHeaderIfChanged(rightPath, "Daylight_Box_Right", Daylight_Box_Right_png, Daylight_Box_Right_png_len)) return false;
    if (!writeHeaderIfChanged(topPath, "Daylight_Box_Top", Daylight_Box_Top_png, Daylight_Box_Top_png_len)) return false;
    if (!writeHeaderIfChanged(bottomPath, "Daylight_Box_Bottom", Daylight_Box_Bottom_png, Daylight_Box_Bottom_png_len)) return false;

    return true;
}

Editor::Factory::Factory(){
}

std::string Editor::Factory::indentation(int spaces) {
    if (spaces <= 0) {
        return "";
    }
    return std::string(static_cast<size_t>(spaces), ' ');
}

std::string Editor::Factory::toIdentifier(const std::string& name) {
    std::string out;
    out.reserve(name.size());

    auto isIdentStart = [](unsigned char c) {
        return std::isalpha(c) || c == '_';
    };
    auto isIdentChar = [](unsigned char c) {
        return std::isalnum(c) || c == '_';
    };

    bool lastWasUnderscore = false;
    for (unsigned char c : name) {
        if (isIdentChar(c)) {
            out.push_back(static_cast<char>(c));
            lastWasUnderscore = (c == '_');
        } else {
            if (!out.empty() && !lastWasUnderscore) {
                out.push_back('_');
                lastWasUnderscore = true;
            }
        }
    }

    while (!out.empty() && out.front() == '_') {
        out.erase(out.begin());
    }
    while (!out.empty() && out.back() == '_') {
        out.pop_back();
    }

    if (out.empty()) {
        out = "var";
    }

    if (!isIdentStart(static_cast<unsigned char>(out[0]))) {
        out.insert(out.begin(), '_');
    }

    static const std::unordered_set<std::string> kCppKeywords = {
        "alignas", "alignof", "and", "and_eq", "asm", "auto", "bitand", "bitor",
        "bool", "break", "case", "catch", "char", "char8_t", "char16_t", "char32_t",
        "class", "compl", "concept", "const", "consteval", "constexpr", "constinit",
        "const_cast", "continue", "co_await", "co_return", "co_yield", "decltype",
        "default", "delete", "do", "double", "dynamic_cast", "else", "enum", "explicit",
        "export", "extern", "false", "float", "for", "friend", "goto", "if", "inline",
        "int", "long", "mutable", "namespace", "new", "noexcept", "not", "not_eq",
        "nullptr", "operator", "or", "or_eq", "private", "protected", "public", "register",
        "reinterpret_cast", "requires", "return", "short", "signed", "sizeof", "static",
        "static_assert", "static_cast", "struct", "switch", "template", "this", "thread_local",
        "throw", "true", "try", "typedef", "typeid", "typename", "union", "unsigned",
        "using", "virtual", "void", "volatile", "wchar_t", "while", "xor", "xor_eq"
    };

    if (kCppKeywords.find(out) != kCppKeywords.end()) {
        out.push_back('_');
    }

    return out;
}

std::string Editor::Factory::formatVector2(const Vector2& v) {
    std::ostringstream oss;
    oss << std::fixed << std::setprecision(6);
    oss << "Vector2(" << v.x << "f, " << v.y << "f)";
    return oss.str();
}

std::string Editor::Factory::formatVector3(const Vector3& v) {
    std::ostringstream oss;
    oss << std::fixed << std::setprecision(6);
    oss << "Vector3(" << v.x << "f, " << v.y << "f, " << v.z << "f)";
    return oss.str();
}

std::string Editor::Factory::formatVector4(const Vector4& v) {
    std::ostringstream oss;
    oss << std::fixed << std::setprecision(6);
    oss << "Vector4(" << v.x << "f, " << v.y << "f, " << v.z << "f, " << v.w << "f)";
    return oss.str();
}

std::string Editor::Factory::formatRect(const Rect& r) {
    std::ostringstream oss;
    oss << std::fixed << std::setprecision(6);
    oss << "Rect(" << r.getX() << "f, " << r.getY() << "f, " << r.getWidth() << "f, " << r.getHeight() << "f)";
    return oss.str();
}

std::string Editor::Factory::formatPrimitiveType(PrimitiveType type) {
    switch (type) {
        case PrimitiveType::TRIANGLES: return "PrimitiveType::TRIANGLES";
        case PrimitiveType::TRIANGLE_STRIP: return "PrimitiveType::TRIANGLE_STRIP";
        case PrimitiveType::POINTS: return "PrimitiveType::POINTS";
        case PrimitiveType::LINES: return "PrimitiveType::LINES";
        default: return "PrimitiveType::TRIANGLES";
    }
}

std::string Editor::Factory::formatPivotPreset(PivotPreset preset) {
    switch (preset) {
        case PivotPreset::CENTER: return "PivotPreset::CENTER";
        case PivotPreset::TOP_CENTER: return "PivotPreset::TOP_CENTER";
        case PivotPreset::BOTTOM_CENTER: return "PivotPreset::BOTTOM_CENTER";
        case PivotPreset::LEFT_CENTER: return "PivotPreset::LEFT_CENTER";
        case PivotPreset::RIGHT_CENTER: return "PivotPreset::RIGHT_CENTER";
        case PivotPreset::TOP_LEFT: return "PivotPreset::TOP_LEFT";
        case PivotPreset::BOTTOM_LEFT: return "PivotPreset::BOTTOM_LEFT";
        case PivotPreset::TOP_RIGHT: return "PivotPreset::TOP_RIGHT";
        case PivotPreset::BOTTOM_RIGHT: return "PivotPreset::BOTTOM_RIGHT";
        default: return "PivotPreset::BOTTOM_LEFT";
    }
}

std::string Editor::Factory::formatLightType(LightType type) {
    switch (type) {
        case LightType::DIRECTIONAL: return "LightType::DIRECTIONAL";
        case LightType::POINT: return "LightType::POINT";
        case LightType::SPOT: return "LightType::SPOT";
        default: return "LightType::DIRECTIONAL";
    }
}

std::string Editor::Factory::formatCameraType(CameraType type) {
    switch (type) {
        case CameraType::CAMERA_2D: return "CameraType::CAMERA_2D";
        case CameraType::CAMERA_ORTHO: return "CameraType::CAMERA_ORTHO";
        case CameraType::CAMERA_PERSPECTIVE: return "CameraType::CAMERA_PERSPECTIVE";
        default: return "CameraType::CAMERA_2D";
    }
}

std::string Editor::Factory::formatScriptType(ScriptType type) {
    switch (type) {
        case ScriptType::SUBCLASS: return "ScriptType::SUBCLASS";
        case ScriptType::SCRIPT_CLASS: return "ScriptType::SCRIPT_CLASS";
        case ScriptType::SCRIPT_LUA: return "ScriptType::SCRIPT_LUA";
        default: return "ScriptType::SUBCLASS";
    }
}

std::string Editor::Factory::formatQuaternion(const Quaternion& q) {
    std::ostringstream oss;
    oss << std::fixed << std::setprecision(6);
    oss << "Quaternion(" << q.w << "f, " << q.x << "f, " << q.y << "f, " << q.z << "f)";
    return oss.str();
}

std::string Editor::Factory::formatBool(bool value) {
    return value ? "true" : "false";
}

std::string Editor::Factory::formatFloat(float value) {
    std::ostringstream oss;
    oss << std::fixed << std::setprecision(6);
    oss << value << "f";
    return oss.str();
}

std::string Editor::Factory::formatInt(int value) {
    return std::to_string(value);
}

std::string Editor::Factory::formatUInt(unsigned int value) {
    return std::to_string(value);
}

std::string Editor::Factory::formatString(const std::string& value) {
    return "\"" + value + "\"";
}

std::string Editor::Factory::formatAttributeType(AttributeType type) {
    switch (type) {
        case AttributeType::INDEX: return "AttributeType::INDEX";
        case AttributeType::POSITION: return "AttributeType::POSITION";
        case AttributeType::TEXCOORD1: return "AttributeType::TEXCOORD1";
        case AttributeType::NORMAL: return "AttributeType::NORMAL";
        case AttributeType::TANGENT: return "AttributeType::TANGENT";
        case AttributeType::COLOR: return "AttributeType::COLOR";
        case AttributeType::POINTSIZE: return "AttributeType::POINTSIZE";
        case AttributeType::POINTROTATION: return "AttributeType::POINTROTATION";
        case AttributeType::TEXTURERECT: return "AttributeType::TEXTURERECT";
        case AttributeType::BONEWEIGHTS: return "AttributeType::BONEWEIGHTS";
        case AttributeType::BONEIDS: return "AttributeType::BONEIDS";
        case AttributeType::MORPHTARGET0: return "AttributeType::MORPHTARGET0";
        case AttributeType::MORPHTARGET1: return "AttributeType::MORPHTARGET1";
        case AttributeType::MORPHTARGET2: return "AttributeType::MORPHTARGET2";
        case AttributeType::MORPHTARGET3: return "AttributeType::MORPHTARGET3";
        case AttributeType::MORPHTARGET4: return "AttributeType::MORPHTARGET4";
        case AttributeType::MORPHTARGET5: return "AttributeType::MORPHTARGET5";
        case AttributeType::MORPHTARGET6: return "AttributeType::MORPHTARGET6";
        case AttributeType::MORPHTARGET7: return "AttributeType::MORPHTARGET7";
        case AttributeType::MORPHNORMAL0: return "AttributeType::MORPHNORMAL0";
        case AttributeType::MORPHNORMAL1: return "AttributeType::MORPHNORMAL1";
        case AttributeType::MORPHNORMAL2: return "AttributeType::MORPHNORMAL2";
        case AttributeType::MORPHNORMAL3: return "AttributeType::MORPHNORMAL3";
        case AttributeType::MORPHTANGENT0: return "AttributeType::MORPHTANGENT0";
        case AttributeType::MORPHTANGENT1: return "AttributeType::MORPHTANGENT1";
        case AttributeType::INSTANCEMATRIXCOL1: return "AttributeType::INSTANCEMATRIXCOL1";
        case AttributeType::INSTANCEMATRIXCOL2: return "AttributeType::INSTANCEMATRIXCOL2";
        case AttributeType::INSTANCEMATRIXCOL3: return "AttributeType::INSTANCEMATRIXCOL3";
        case AttributeType::INSTANCEMATRIXCOL4: return "AttributeType::INSTANCEMATRIXCOL4";
        case AttributeType::INSTANCECOLOR: return "AttributeType::INSTANCECOLOR";
        case AttributeType::INSTANCETEXTURERECT: return "AttributeType::INSTANCETEXTURERECT";
        case AttributeType::TERRAINNODEPOSITION: return "AttributeType::TERRAINNODEPOSITION";
        case AttributeType::TERRAINNODESIZE: return "AttributeType::TERRAINNODESIZE";
        case AttributeType::TERRAINNODERANGE: return "AttributeType::TERRAINNODERANGE";
        case AttributeType::TERRAINNODERESOLUTION: return "AttributeType::TERRAINNODERESOLUTION";
        default: return "AttributeType::POSITION";
    }
}

std::string Editor::Factory::formatAttributeDataType(AttributeDataType type) {
    switch (type) {
        case AttributeDataType::BYTE: return "AttributeDataType::BYTE";
        case AttributeDataType::UNSIGNED_BYTE: return "AttributeDataType::UNSIGNED_BYTE";
        case AttributeDataType::SHORT: return "AttributeDataType::SHORT";
        case AttributeDataType::UNSIGNED_SHORT: return "AttributeDataType::UNSIGNED_SHORT";
        case AttributeDataType::INT: return "AttributeDataType::INT";
        case AttributeDataType::UNSIGNED_INT: return "AttributeDataType::UNSIGNED_INT";
        case AttributeDataType::FLOAT: return "AttributeDataType::FLOAT";
        default: return "AttributeDataType::FLOAT";
    }
}

std::string Editor::Factory::formatTextureFilter(TextureFilter filter) {
    switch (filter) {
        case TextureFilter::NEAREST: return "TextureFilter::NEAREST";
        case TextureFilter::LINEAR: return "TextureFilter::LINEAR";
        case TextureFilter::NEAREST_MIPMAP_NEAREST: return "TextureFilter::NEAREST_MIPMAP_NEAREST";
        case TextureFilter::NEAREST_MIPMAP_LINEAR: return "TextureFilter::NEAREST_MIPMAP_LINEAR";
        case TextureFilter::LINEAR_MIPMAP_NEAREST: return "TextureFilter::LINEAR_MIPMAP_NEAREST";
        case TextureFilter::LINEAR_MIPMAP_LINEAR: return "TextureFilter::LINEAR_MIPMAP_LINEAR";
        default: return "TextureFilter::LINEAR";
    }
}

std::string Editor::Factory::formatTextureWrap(TextureWrap wrap) {
    switch (wrap) {
        case TextureWrap::REPEAT: return "TextureWrap::REPEAT";
        case TextureWrap::MIRRORED_REPEAT: return "TextureWrap::MIRRORED_REPEAT";
        case TextureWrap::CLAMP_TO_EDGE: return "TextureWrap::CLAMP_TO_EDGE";
        case TextureWrap::CLAMP_TO_BORDER: return "TextureWrap::CLAMP_TO_BORDER";
        default: return "TextureWrap::REPEAT";
    }
}

std::string Editor::Factory::formatScriptPropertyType(ScriptPropertyType type) {
    switch (type) {
        case ScriptPropertyType::Bool: return "ScriptPropertyType::Bool";
        case ScriptPropertyType::Int: return "ScriptPropertyType::Int";
        case ScriptPropertyType::Float: return "ScriptPropertyType::Float";
        case ScriptPropertyType::String: return "ScriptPropertyType::String";
        case ScriptPropertyType::Vector2: return "ScriptPropertyType::Vector2";
        case ScriptPropertyType::Vector3: return "ScriptPropertyType::Vector3";
        case ScriptPropertyType::Vector4: return "ScriptPropertyType::Vector4";
        case ScriptPropertyType::Color3: return "ScriptPropertyType::Color3";
        case ScriptPropertyType::Color4: return "ScriptPropertyType::Color4";
        case ScriptPropertyType::EntityPointer: return "ScriptPropertyType::EntityPointer";
        default: return "ScriptPropertyType::Bool";
    }
}

std::string Editor::Factory::formatScriptPropertyValue(const Scene* scene, const ScriptPropertyValue& value) {
    if (std::holds_alternative<bool>(value)) {
        return formatBool(std::get<bool>(value));
    } else if (std::holds_alternative<int>(value)) {
        return formatInt(std::get<int>(value));
    } else if (std::holds_alternative<float>(value)) {
        return formatFloat(std::get<float>(value));
    } else if (std::holds_alternative<std::string>(value)) {
        return formatString(std::get<std::string>(value));
    } else if (std::holds_alternative<Vector2>(value)) {
        return formatVector2(std::get<Vector2>(value));
    } else if (std::holds_alternative<Vector3>(value)) {
        return formatVector3(std::get<Vector3>(value));
    } else if (std::holds_alternative<Vector4>(value)) {
        return formatVector4(std::get<Vector4>(value));
    } else if (std::holds_alternative<EntityRef>(value)) {
        const EntityRef& ref = std::get<EntityRef>(value);
        std::string res = "EntityRef{";
        if (ref.scene == scene){
            res += std::to_string(ref.entity) + ", ";
            res += "scene, ";
        } else {
            res += "NULL_ENTITY, ";
            res += "nullptr, "; // different scene, set to nullptr
        }
        res += "EntityLocator{";
        res += formatEntityRefKind(ref.locator.kind) + ", ";
        res += std::to_string(ref.locator.scopedEntity) + ", ";
        res += std::to_string(ref.locator.sceneId) + ", ";
        res += formatString(ref.locator.sharedPath);
        res += "}}";
        return res;
    }
    return "ScriptPropertyValue{}";
}

std::string Editor::Factory::formatEntityRefKind(EntityRefKind kind) {
    switch (kind) {
        case EntityRefKind::None: return "EntityRefKind::None";
        case EntityRefKind::LocalEntity: return "EntityRefKind::LocalEntity";
        case EntityRefKind::SharedEntity: return "EntityRefKind::SharedEntity";
        default: return "EntityRefKind::None";
    }
}

std::string Editor::Factory::formatTexture(int indentSpaces, const Texture& texture, const std::string& variableName, const fs::path& projectPath) {
    if (texture.empty()) return "";
    std::ostringstream code;
    std::string ind = indentation(indentSpaces);

    auto normalizePath = [&](const std::string& inPath) {
        std::string outPath = inPath;
        if (!outPath.empty() && !projectPath.empty()) {
            fs::path tPath = outPath;
            try {
                outPath = fs::relative(tPath, projectPath).string();
            } catch (...) {
            }
        }
        return outPath;
    };

    const bool isCube = texture.isCubeMap() || (texture.getNumFaces() == 6);
    if (isCube) {
        bool hasAnyNonZeroFace = false;
        for (int f = 1; f < 6; f++) {
            if (!texture.getPath((size_t)f).empty()) {
                hasAnyNonZeroFace = true;
                break;
            }
        }

        const std::string p0 = normalizePath(texture.getPath(0));
        const bool singleFileCube = !p0.empty() && !hasAnyNonZeroFace;
        if (singleFileCube) {
            code << ind << variableName << ".setCubeMap(" << formatString(p0) << ");\n";
        } else {
            // Face indices (engine order): 0=Right(+X), 1=Left(-X), 2=Top(+Y), 3=Bottom(-Y), 4=Front(+Z), 5=Back(-Z)
            const std::string p1 = normalizePath(texture.getPath(1));
            const std::string p2 = normalizePath(texture.getPath(2));
            const std::string p3 = normalizePath(texture.getPath(3));
            const std::string p4 = normalizePath(texture.getPath(4));
            const std::string p5 = normalizePath(texture.getPath(5));

            // setCubePaths takes OpenGL-style naming: (front, back, left, right, up, down)
            code << ind << variableName << ".setCubePaths(";
            code << formatString(p4) << ", " << formatString(p5) << ", ";
            code << formatString(p1) << ", " << formatString(p0) << ", ";
            code << formatString(p2) << ", " << formatString(p3);
            code << ");\n";
        }
    } else {
        const std::string p0 = normalizePath(texture.getPath(0));
        if (!p0.empty()) {
            code << ind << variableName << ".setPath(" << formatString(p0) << ");\n";
        } else if (!texture.getId().empty()) {
            // Path-less textures (e.g., runtime provided). Note: setId() alone does not force a file load.
            code << ind << variableName << ".setId(" << formatString(texture.getId()) << ");\n";
        }
    }

    code << ind << variableName << ".setMinFilter(" << formatTextureFilter(texture.getMinFilter()) << ");\n";
    code << ind << variableName << ".setMagFilter(" << formatTextureFilter(texture.getMagFilter()) << ");\n";
    code << ind << variableName << ".setWrapU(" << formatTextureWrap(texture.getWrapU()) << ");\n";
    code << ind << variableName << ".setWrapV(" << formatTextureWrap(texture.getWrapV()) << ");\n";

    return code.str();
}

std::string Editor::Factory::formatPropertyValue(const PropertyData& property, const std::string& propertyName) {
    switch (property.type) {
        case PropertyType::Bool: {
            bool* value = static_cast<bool*>(property.ref);
            return formatBool(*value);
        }
        case PropertyType::Float: {
            float* value = static_cast<float*>(property.ref);
            return formatFloat(*value);
        }
        case PropertyType::Int: {
            int* value = static_cast<int*>(property.ref);
            return formatInt(*value);
        }
        case PropertyType::UInt: {
            unsigned int* value = static_cast<unsigned int*>(property.ref);
            return formatUInt(*value);
        }
        case PropertyType::Vector2: {
            Vector2* value = static_cast<Vector2*>(property.ref);
            return formatVector2(*value);
        }
        case PropertyType::Vector3: {
            Vector3* value = static_cast<Vector3*>(property.ref);
            return formatVector3(*value);
        }
        case PropertyType::Vector4: {
            Vector4* value = static_cast<Vector4*>(property.ref);
            return formatVector4(*value);
        }
        case PropertyType::Quat: {
            Quaternion* value = static_cast<Quaternion*>(property.ref);
            return formatQuaternion(*value);
        }
        case PropertyType::String: {
            std::string* value = static_cast<std::string*>(property.ref);
            return formatString(*value);
        }
        case PropertyType::Enum: {
            int* value = static_cast<int*>(property.ref);
            return formatInt(*value);
        }
        case PropertyType::Material:
        case PropertyType::Texture:
        default:
            return "/* unsupported property type */";
    }
}

void Editor::Factory::addComponentCode(std::ostringstream& code, const std::string& ind, const std::string& sceneName, const std::string& entityName, Entity entity, const std::string& componentType, const std::string& varName) {
    if (!sceneName.empty()) {
        std::string entityRef = entityName.empty() ? std::to_string(entity) : entityName;
        if (sceneName == "scene")
            code << ind << sceneName << "->addComponent<" << componentType << ">(" << entityRef << ", " << varName << ");\n";
        else
            code << ind << sceneName << ".addComponent<" << componentType << ">(" << entityRef << ", " << varName << ");\n";
    }
}

std::string Editor::Factory::createTransform(int indentSpaces, Scene* scene, Entity entity, std::string sceneName, std::string entityName) {
    if (!scene->findComponent<Transform>(entity)) return "";
    Transform& transform = scene->getComponent<Transform>(entity);
    std::ostringstream code;
    const std::string ind = indentation(indentSpaces);
    code << ind << "Transform transform;\n";
    code << ind << "transform.position = " << formatVector3(transform.position) << ";\n";
    code << ind << "transform.rotation = " << formatQuaternion(transform.rotation) << ";\n";
    code << ind << "transform.scale = " << formatVector3(transform.scale) << ";\n";
    code << ind << "transform.visible = " << formatBool(transform.visible) << ";\n";
    code << ind << "transform.billboard = " << formatBool(transform.billboard) << ";\n";
    code << ind << "transform.fakeBillboard = " << formatBool(transform.fakeBillboard) << ";\n";
    code << ind << "transform.cylindricalBillboard = " << formatBool(transform.cylindricalBillboard) << ";\n";
    code << ind << "transform.billboardRotation = " << formatQuaternion(transform.billboardRotation) << ";\n";
    addComponentCode(code, ind, sceneName, entityName, entity, "Transform", "transform");
    return code.str();
}

std::string Editor::Factory::createMeshComponent(int indentSpaces, Scene* scene, Entity entity, const fs::path& projectPath, std::string sceneName, std::string entityName) {
    if (!scene->findComponent<MeshComponent>(entity)) return "";
    MeshComponent& mesh = scene->getComponent<MeshComponent>(entity);
    std::ostringstream code;
    const std::string ind = indentation(indentSpaces);
    code << ind << "MeshComponent mesh;\n";
    code << ind << "mesh.castShadows = " << formatBool(mesh.castShadows) << ";\n";
    code << ind << "mesh.receiveShadows = " << formatBool(mesh.receiveShadows) << ";\n";
    code << ind << "mesh.vertexCount = " << formatUInt(mesh.vertexCount) << ";\n";
    //code << ind << "mesh.submeshes.resize(" << formatUInt(mesh.numSubmeshes) << ");\n";
    code << ind << "mesh.numSubmeshes = " << formatUInt(mesh.numSubmeshes) << ";\n";
    for (unsigned int s = 0; s < mesh.numSubmeshes; s++){
        std::string idx = std::to_string(s);
        code << ind << "mesh.submeshes[" << idx << "].material.name = " << formatString(mesh.submeshes[s].material.name) << ";\n";
        code << ind << "mesh.submeshes[" << idx << "].material.baseColorFactor = " << formatVector4(mesh.submeshes[s].material.baseColorFactor) << ";\n";
        code << ind << "mesh.submeshes[" << idx << "].material.metallicFactor = " << formatFloat(mesh.submeshes[s].material.metallicFactor) << ";\n";
        code << ind << "mesh.submeshes[" << idx << "].material.roughnessFactor = " << formatFloat(mesh.submeshes[s].material.roughnessFactor) << ";\n";
        code << ind << "mesh.submeshes[" << idx << "].material.emissiveFactor = " << formatVector3(mesh.submeshes[s].material.emissiveFactor) << ";\n";

        code << formatTexture(indentSpaces, mesh.submeshes[s].material.baseColorTexture, "mesh.submeshes[" + idx + "].material.baseColorTexture", projectPath);
        code << formatTexture(indentSpaces, mesh.submeshes[s].material.emissiveTexture, "mesh.submeshes[" + idx + "].material.emissiveTexture", projectPath);
        code << formatTexture(indentSpaces, mesh.submeshes[s].material.metallicRoughnessTexture, "mesh.submeshes[" + idx + "].material.metallicRoughnessTexture", projectPath);
        code << formatTexture(indentSpaces, mesh.submeshes[s].material.occlusionTexture, "mesh.submeshes[" + idx + "].material.occlusionTexture", projectPath);
        code << formatTexture(indentSpaces, mesh.submeshes[s].material.normalTexture, "mesh.submeshes[" + idx + "].material.normalTexture", projectPath);

        code << ind << "mesh.submeshes[" << idx << "].primitiveType = " << formatPrimitiveType(mesh.submeshes[s].primitiveType) << ";\n";
        code << ind << "mesh.submeshes[" << idx << "].vertexCount = " << formatUInt(mesh.submeshes[s].vertexCount) << ";\n";
        code << ind << "mesh.submeshes[" << idx << "].faceCulling = " << formatBool(mesh.submeshes[s].faceCulling) << ";\n";
        code << ind << "mesh.submeshes[" << idx << "].textureShadow = " << formatBool(mesh.submeshes[s].textureShadow) << ";\n";
        code << ind << "mesh.submeshes[" << idx << "].textureRect = " << formatRect(mesh.submeshes[s].textureRect) << ";\n";
    }

    if (mesh.buffer.getSize() > 0){
        code << ind << "mesh.buffer.clearAll();\n";
        std::map<AttributeType, Attribute> attributes = mesh.buffer.getAttributes();

        std::vector<std::pair<AttributeType, Attribute>> sortedAttributes(attributes.begin(), attributes.end());
        std::sort(sortedAttributes.begin(), sortedAttributes.end(), 
            [](const std::pair<AttributeType, Attribute>& a, const std::pair<AttributeType, Attribute>& b) {
                return a.second.getOffset() < b.second.getOffset();
            });

        for (auto const& [type, val] : sortedAttributes) {
            std::string perInstanceCode = "";
            if (val.getPerInstance())
                perInstanceCode = ", true";
            code << ind << "mesh.buffer.addAttribute(" << formatAttributeType(type) << ", " << val.getElements() << perInstanceCode << ");\n";
        }

        code << ind << "{\n";
        code << ind << "    unsigned char data[] = {";
        unsigned char* bufData = mesh.buffer.getData();
        for(size_t i=0; i<mesh.buffer.getSize(); i++){
                if (i % 50 == 0) code << "\n" << ind << "        ";
                code << "0x" << std::hex << (int)bufData[i] << std::dec << ", ";
        }
        code << "};\n";
        code << ind << "    mesh.buffer.importData(data, sizeof(data));\n";
        code << ind << "}\n";
        code << ind << "mesh.buffer.setCount(" << formatUInt(mesh.buffer.getCount()) << ");\n";
    }

    if (mesh.indices.getSize() > 0){
        code << ind << "mesh.indices.clearAll();\n";
        code << ind << "{\n";
        code << ind << "    unsigned char data[] = {";
        unsigned char* idxData = mesh.indices.getData();
        for(size_t i=0; i<mesh.indices.getSize(); i++){
                if (i % 50 == 0) code << "\n" << ind << "        ";
                code << "0x" << std::hex << (int)idxData[i] << std::dec << ", ";
        }
        code << "};\n";
        code << ind << "    mesh.indices.importData(data, sizeof(data));\n";
        code << ind << "}\n";
        code << ind << "mesh.indices.setCount(" << formatUInt(mesh.indices.getCount()) << ");\n";
    }

    addComponentCode(code, ind, sceneName, entityName, entity, "MeshComponent", "mesh");
    return code.str();
}

std::string Editor::Factory::createUIComponent(int indentSpaces, Scene* scene, Entity entity, const fs::path& projectPath, std::string sceneName, std::string entityName) {
    if (!scene->findComponent<UIComponent>(entity)) return "";
    UIComponent& ui = scene->getComponent<UIComponent>(entity);
    std::ostringstream code;
    const std::string ind = indentation(indentSpaces);
    code << ind << "UIComponent ui;\n";
    code << ind << "ui.color = " << formatVector4(ui.color) << ";\n";
    code << formatTexture(indentSpaces, ui.texture, "ui.texture", projectPath);
    addComponentCode(code, ind, sceneName, entityName, entity, "UIComponent", "ui");
    return code.str();
}

std::string Editor::Factory::createUILayoutComponent(int indentSpaces, Scene* scene, Entity entity, std::string sceneName, std::string entityName) {
    if (!scene->findComponent<UILayoutComponent>(entity)) return "";
    UILayoutComponent& layout = scene->getComponent<UILayoutComponent>(entity);
    std::ostringstream code;
    const std::string ind = indentation(indentSpaces);
    code << ind << "UILayoutComponent layout;\n";
    code << ind << "layout.width = " << formatUInt(layout.width) << ";\n";
    code << ind << "layout.height = " << formatUInt(layout.height) << ";\n";
    code << ind << "layout.ignoreScissor = " << formatBool(layout.ignoreScissor) << ";\n";
    addComponentCode(code, ind, sceneName, entityName, entity, "UILayoutComponent", "layout");
    return code.str();
}

std::string Editor::Factory::createImageComponent(int indentSpaces, Scene* scene, Entity entity, std::string sceneName, std::string entityName) {
    if (!scene->findComponent<ImageComponent>(entity)) return "";
    ImageComponent& image = scene->getComponent<ImageComponent>(entity);
    std::ostringstream code;
    const std::string ind = indentation(indentSpaces);
    code << ind << "ImageComponent image;\n";
    code << ind << "image.patchMarginLeft = " << formatUInt(image.patchMarginLeft) << ";\n";
    code << ind << "image.patchMarginRight = " << formatUInt(image.patchMarginRight) << ";\n";
    code << ind << "image.patchMarginTop = " << formatUInt(image.patchMarginTop) << ";\n";
    code << ind << "image.patchMarginBottom = " << formatUInt(image.patchMarginBottom) << ";\n";
    code << ind << "image.textureScaleFactor = " << formatFloat(image.textureScaleFactor) << ";\n";
    addComponentCode(code, ind, sceneName, entityName, entity, "ImageComponent", "image");
    return code.str();
}

std::string Editor::Factory::createSpriteComponent(int indentSpaces, Scene* scene, Entity entity, std::string sceneName, std::string entityName) {
    if (!scene->findComponent<SpriteComponent>(entity)) return "";
    SpriteComponent& sprite = scene->getComponent<SpriteComponent>(entity);
    std::ostringstream code;
    const std::string ind = indentation(indentSpaces);
    code << ind << "SpriteComponent sprite;\n";
    code << ind << "sprite.width = " << formatUInt(sprite.width) << ";\n";
    code << ind << "sprite.height = " << formatUInt(sprite.height) << ";\n";
    code << ind << "sprite.pivotPreset = " << formatPivotPreset(sprite.pivotPreset) << ";\n";
    code << ind << "sprite.textureScaleFactor = " << formatFloat(sprite.textureScaleFactor) << ";\n";
    addComponentCode(code, ind, sceneName, entityName, entity, "SpriteComponent", "sprite");
    return code.str();
}

std::string Editor::Factory::createLightComponent(int indentSpaces, Scene* scene, Entity entity, std::string sceneName, std::string entityName) {
    if (!scene->findComponent<LightComponent>(entity)) return "";
    LightComponent& light = scene->getComponent<LightComponent>(entity);
    std::ostringstream code;
    const std::string ind = indentation(indentSpaces);
    code << ind << "LightComponent light;\n";
    code << ind << "light.type = " << formatLightType(light.type) << ";\n";
    code << ind << "light.direction = " << formatVector3(light.direction) << ";\n";
    code << ind << "light.shadows = " << formatBool(light.shadows) << ";\n";
    code << ind << "light.intensity = " << formatFloat(light.intensity) << ";\n";
    code << ind << "light.range = " << formatFloat(light.range) << ";\n";
    code << ind << "light.color = " << formatVector3(light.color) << ";\n";
    code << ind << "light.innerConeCos = " << formatFloat(light.innerConeCos) << ";\n";
    code << ind << "light.outerConeCos = " << formatFloat(light.outerConeCos) << ";\n";
    code << ind << "light.shadowBias = " << formatFloat(light.shadowBias) << ";\n";
    code << ind << "light.mapResolution = " << formatUInt(light.mapResolution) << ";\n";
    code << ind << "light.automaticShadowCamera = " << formatBool(light.automaticShadowCamera) << ";\n";
    code << ind << "light.shadowCameraNearFar.x = " << formatFloat(light.shadowCameraNearFar.x) << ";\n";
    code << ind << "light.shadowCameraNearFar.y = " << formatFloat(light.shadowCameraNearFar.y) << ";\n";
    code << ind << "light.numShadowCascades = " << formatUInt(light.numShadowCascades) << ";\n";
    addComponentCode(code, ind, sceneName, entityName, entity, "LightComponent", "light");
    return code.str();
}

std::string Editor::Factory::createCameraComponent(int indentSpaces, Scene* scene, Entity entity, std::string sceneName, std::string entityName) {
    if (!scene->findComponent<CameraComponent>(entity)) return "";
    CameraComponent& camera = scene->getComponent<CameraComponent>(entity);
    std::ostringstream code;
    const std::string ind = indentation(indentSpaces);
    code << ind << "CameraComponent camera;\n";
    code << ind << "camera.type = " << formatCameraType(camera.type) << ";\n";
    code << ind << "camera.target = " << formatVector3(camera.target) << ";\n";
    code << ind << "camera.up = " << formatVector3(camera.up) << ";\n";
    code << ind << "camera.leftClip = " << formatFloat(camera.leftClip) << ";\n";
    code << ind << "camera.rightClip = " << formatFloat(camera.rightClip) << ";\n";
    code << ind << "camera.bottomClip = " << formatFloat(camera.bottomClip) << ";\n";
    code << ind << "camera.topClip = " << formatFloat(camera.topClip) << ";\n";
    code << ind << "camera.yfov = " << formatFloat(camera.yfov) << ";\n";
    code << ind << "camera.aspect = " << formatFloat(camera.aspect) << ";\n";
    code << ind << "camera.nearClip = " << formatFloat(camera.nearClip) << ";\n";
    code << ind << "camera.farClip = " << formatFloat(camera.farClip) << ";\n";
    code << ind << "camera.renderToTexture = " << formatBool(camera.renderToTexture) << ";\n";
    code << ind << "camera.transparentSort = " << formatBool(camera.transparentSort) << ";\n";
    code << ind << "camera.useTarget = " << formatBool(camera.useTarget) << ";\n";
    code << ind << "camera.autoResize = " << formatBool(camera.autoResize) << ";\n";
    addComponentCode(code, ind, sceneName, entityName, entity, "CameraComponent", "camera");
    return code.str();
}

std::string Editor::Factory::createScriptComponent(int indentSpaces, Scene* scene, Entity entity, std::string sceneName, std::string entityName) {
    if (!scene->findComponent<ScriptComponent>(entity)) return "";
    ScriptComponent& script = scene->getComponent<ScriptComponent>(entity);
    std::ostringstream code;
    const std::string ind = indentation(indentSpaces);
    code << ind << "ScriptComponent script;\n";

    for (size_t i = 0; i < script.scripts.size(); i++) {
        std::string idx = std::to_string(i);
        code << ind << "script.scripts.push_back(ScriptEntry());\n";
        code << ind << "script.scripts[" << idx << "].type = " << formatScriptType(script.scripts[i].type) << ";\n";
        code << ind << "script.scripts[" << idx << "].path = " << formatString(script.scripts[i].path) << ";\n";
        code << ind << "script.scripts[" << idx << "].headerPath = " << formatString(script.scripts[i].headerPath) << ";\n";
        code << ind << "script.scripts[" << idx << "].className = " << formatString(script.scripts[i].className) << ";\n";
        code << ind << "script.scripts[" << idx << "].enabled = " << formatBool(script.scripts[i].enabled) << ";\n";

        for (size_t p = 0; p < script.scripts[i].properties.size(); p++) {
            const ScriptProperty& prop = script.scripts[i].properties[p];
            std::string pidx = std::to_string(p);
            code << ind << "script.scripts[" << idx << "].properties.push_back(ScriptProperty());\n";
            code << ind << "script.scripts[" << idx << "].properties[" << pidx << "].name = " << formatString(prop.name) << ";\n";
            code << ind << "script.scripts[" << idx << "].properties[" << pidx << "].type = " << formatScriptPropertyType(prop.type) << ";\n";
            code << ind << "script.scripts[" << idx << "].properties[" << pidx << "].value = " << formatScriptPropertyValue(scene, prop.value) << ";\n";
        }
    }

    addComponentCode(code, ind, sceneName, entityName, entity, "ScriptComponent", "script");
    return code.str();
}

std::string Editor::Factory::createSkyComponent(int indentSpaces, Scene* scene, Entity entity, const fs::path& projectPath, std::string sceneName, std::string entityName) {
    if (!scene->findComponent<SkyComponent>(entity)) return "";
    SkyComponent& sky = scene->getComponent<SkyComponent>(entity);
    std::ostringstream code;
    const std::string ind = indentation(indentSpaces);
    code << ind << "SkyComponent sky;\n";

    if (sky.texture.getId() == DEFAULT_SKY_ID) {
        code << ind << "TextureData skyFront;\n";
        code << ind << "TextureData skyBack;\n";
        code << ind << "TextureData skyLeft;\n";
        code << ind << "TextureData skyRight;\n";
        code << ind << "TextureData skyTop;\n";
        code << ind << "TextureData skyBottom;\n";

        code << ind << "skyFront.loadTextureFromMemory(Daylight_Box_Front_data, Daylight_Box_Front_len);\n";
        code << ind << "skyBack.loadTextureFromMemory(Daylight_Box_Back_data, Daylight_Box_Back_len);\n";
        code << ind << "skyLeft.loadTextureFromMemory(Daylight_Box_Left_data, Daylight_Box_Left_len);\n";
        code << ind << "skyRight.loadTextureFromMemory(Daylight_Box_Right_data, Daylight_Box_Right_len);\n";
        code << ind << "skyTop.loadTextureFromMemory(Daylight_Box_Top_data, Daylight_Box_Top_len);\n";
        code << ind << "skyBottom.loadTextureFromMemory(Daylight_Box_Bottom_data, Daylight_Box_Bottom_len);\n";

        code << ind << "sky.texture.setId(" << formatString(sky.texture.getId()) << ");\n";
        code << ind << "sky.texture.setCubeDatas(" << formatString(sky.texture.getId()) << ", skyFront, skyBack, skyLeft, skyRight, skyTop, skyBottom);\n";
        code << ind << "sky.texture.setMinFilter(" << formatTextureFilter(sky.texture.getMinFilter()) << ");\n";
        code << ind << "sky.texture.setMagFilter(" << formatTextureFilter(sky.texture.getMagFilter()) << ");\n";
        code << ind << "sky.texture.setWrapU(" << formatTextureWrap(sky.texture.getWrapU()) << ");\n";
        code << ind << "sky.texture.setWrapV(" << formatTextureWrap(sky.texture.getWrapV()) << ");\n";
    } else {
        code << formatTexture(indentSpaces, sky.texture, "sky.texture", projectPath);
    }
    code << ind << "sky.color = " << formatVector4(sky.color) << ";\n";
    code << ind << "sky.rotation = " << formatFloat(sky.rotation) << ";\n";

    addComponentCode(code, ind, sceneName, entityName, entity, "SkyComponent", "sky");
    return code.str();
}

std::string Editor::Factory::createComponent(int indentSpaces, Scene* scene, Entity entity, ComponentType componentType, const fs::path& projectPath, std::string sceneName, std::string entityName) {
    switch (componentType) {
        case ComponentType::Transform: return createTransform(indentSpaces, scene, entity, sceneName, entityName);
        case ComponentType::MeshComponent: return createMeshComponent(indentSpaces, scene, entity, projectPath, sceneName, entityName);
        case ComponentType::UIComponent: return createUIComponent(indentSpaces, scene, entity, projectPath, sceneName, entityName);
        case ComponentType::UILayoutComponent: return createUILayoutComponent(indentSpaces, scene, entity, sceneName, entityName);
        case ComponentType::ImageComponent: return createImageComponent(indentSpaces, scene, entity, sceneName, entityName);
        case ComponentType::SpriteComponent: return createSpriteComponent(indentSpaces, scene, entity, sceneName, entityName);
        case ComponentType::LightComponent: return createLightComponent(indentSpaces, scene, entity, sceneName, entityName);
        case ComponentType::CameraComponent: return createCameraComponent(indentSpaces, scene, entity, sceneName, entityName);
        case ComponentType::ScriptComponent: return createScriptComponent(indentSpaces, scene, entity, sceneName, entityName);
        case ComponentType::SkyComponent: return createSkyComponent(indentSpaces, scene, entity, projectPath, sceneName, entityName);
        default: return "";
    }
}

std::string Editor::Factory::createAllComponents(int indentSpaces, Scene* scene, Entity entity, const fs::path& projectPath, std::string sceneName, std::string entityName) {
    // Find all components for this entity
    std::vector<ComponentType> components = Catalog::findComponents(scene, entity);

    std::ostringstream code;
    const std::string ind = indentation(indentSpaces);
    code << ind << "// Entity components initialization\n";

    bool first = true;
    for (ComponentType componentType : components) {
        std::string componentCode = createComponent(indentSpaces, scene, entity, componentType, projectPath, sceneName, entityName);
        if (!componentCode.empty()) {
            if (!first) {
                code << "\n";
            }
            code << componentCode;
            first = false;
        }
    }

    return code.str();
}

std::string Editor::Factory::createScene(int indentSpaces, Scene* scene, std::string name, std::vector<Entity> entities, Entity camera, const fs::path& projectPath, const fs::path& generatedPath) {
    std::ostringstream out;

    std::string mainSceneVar = toIdentifier(name);
    const std::string ind = indentation(indentSpaces);

    bool usesDefaultSky = false;
    for (Entity entity : entities) {
        if (scene->findComponent<SkyComponent>(entity)) {
            SkyComponent& sky = scene->getComponent<SkyComponent>(entity);
            if (sky.texture.getId() == DEFAULT_SKY_ID) {
                usesDefaultSky = true;
                break;
            }
        }
    }

    out << ind << "// This file is auto-generated by Supernova Editor. Do not edit manually.\n\n";
    out << ind << "#include \"Supernova.h\"\n";
    fs::path skyResourcesPath = generatedPath / "resources" / "sky";
    if (usesDefaultSky) {
        ensureDefaultSkyFiles(skyResourcesPath);

        out << ind << "#include \"resources/sky/Daylight_Box_Front.h\"\n";
        out << ind << "#include \"resources/sky/Daylight_Box_Back.h\"\n";
        out << ind << "#include \"resources/sky/Daylight_Box_Left.h\"\n";
        out << ind << "#include \"resources/sky/Daylight_Box_Right.h\"\n";
        out << ind << "#include \"resources/sky/Daylight_Box_Top.h\"\n";
        out << ind << "#include \"resources/sky/Daylight_Box_Bottom.h\"\n";
    }
    out << ind << "\n";
    out << ind << "using namespace Supernova;\n\n";
    out << ind << "extern \"C\" void initSceneScripts(Supernova::Scene* scene);\n\n";

    out << ind << "void create_" << mainSceneVar << "(Scene* scene){\n";

    const std::string ind2 = indentation(indentSpaces+4);
    const std::string ind3 = indentation(indentSpaces+8);

    bool firstEntity = true;

    for (Entity entity : entities) {
        if (!firstEntity) {
            out << "\n";
        }
        firstEntity = false;
        out << ind2 << "{\n";
        std::string entityName = scene->getEntityName(entity);
        out << ind3 << "// Entity " << entity << " (" << entityName << ")\n";
        out << ind3 << "scene->recreateEntity(" << entity << ");\n";
        out << ind3 << "scene->setEntityName(" << entity << ", " << formatString(entityName) << ");\n\n";

        // Create and set all components
        std::string componentsCode = createAllComponents(indentSpaces+8, scene, entity, projectPath, "scene");
        out << componentsCode;
        out << ind2 << "}\n";
    }

    if (camera != NULL_ENTITY){
        if (std::find(entities.begin(), entities.end(), camera) == entities.end()) {
            out << "\n";
            out << ind2 << "// Default Camera " << camera << "\n";
            out << ind2 << "Entity cameraEntity = scene->createSystemEntity();\n";
            out << "\n";
            std::string componentsCode = createAllComponents(indentSpaces+4, scene, camera, projectPath, "scene", "cameraEntity");
            out << componentsCode;
        }else{
            out << "\n";
            out << ind2 << "Entity cameraEntity = " << camera << ";\n";
        }
        out << "\n";
        out << ind2 << "scene->setCamera(cameraEntity);\n";
    }

    out << "\n";
    out << ind2 << "initSceneScripts(scene);\n";
    out << ind << "}\n";

    return out.str();
}

std::string Editor::Factory::setComponent(Scene* scene, Entity entity, ComponentType componentType, const fs::path& projectPath) {
    // Check if entity has this component
    Signature signature = scene->getSignature(entity);
    ComponentId compId = Catalog::getComponentId(scene, componentType);

    if (!signature.test(compId)) {
        return "";
    }

    // Get all properties for this component
    std::map<std::string, PropertyData> properties = Catalog::findEntityProperties(scene, entity, componentType);

    if (properties.empty()) {
        return "";
    }

    std::ostringstream code;
    std::string componentName = Catalog::getComponentName(componentType, false);
    std::string varName = Catalog::getComponentName(componentType, true);

    // Convert first letter to lowercase for variable name
    if (!varName.empty()) {
        varName[0] = std::tolower(varName[0]);
    }

    code << "    if (signature.test(scene->getComponentId<" << componentName << ">())) {\n";
    code << "        " << componentName << "& " << varName << " = scene->getComponent<" << componentName << ">(entity);\n";

    // Generate code for each property
    for (const auto& [propertyName, propertyData] : properties) {
        if (propertyData.type == PropertyType::Texture){
            Texture* tex = static_cast<Texture*>(propertyData.ref);
            code << formatTexture(8, *tex, varName + "." + propertyName, projectPath);
        }else{
            std::string formattedValue = formatPropertyValue(propertyData, propertyName);
            code << "        " << varName << "." << propertyName << " = " << formattedValue << ";\n";
        }
    }

    code << "    }\n";

    return code.str();
}

std::string Editor::Factory::setAllComponents(Scene* scene, Entity entity, const fs::path& projectPath) {
    // Find all components for this entity
    std::vector<ComponentType> components = Catalog::findComponents(scene, entity);

    std::ostringstream code;
    code << "    // Set entity components\n";
    code << "    Signature signature = scene->getSignature(entity);\n";
    code << "\n";

    bool first = true;
    for (ComponentType componentType : components) {
        std::string componentCode = setComponent(scene, entity, componentType, projectPath);
        if (!componentCode.empty()) {
            if (!first) {
                code << "\n";
            }
            code << componentCode;
            first = false;
        }
    }

    return code.str();
}